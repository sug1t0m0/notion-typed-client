import { compile } from 'json-schema-to-typescript';
import { ResolvedDatabaseConfig } from '../types';
import { SchemaGenerator } from './SchemaGenerator';

export class TypeGenerator {
  private schemaGenerator: SchemaGenerator;

  constructor() {
    this.schemaGenerator = new SchemaGenerator();
  }

  async generateTypes(databases: ResolvedDatabaseConfig[]): Promise<string> {
    const types: string[] = [];

    // 基本的な型定義を追加
    types.push(this.generateBaseTypes());

    // 各データベースの型を生成
    for (const database of databases) {
      const dbTypes = await this.generateDatabaseTypes(database);
      types.push(dbTypes);
    }

    // データベースマッピング型を生成
    types.push(this.generateDatabaseMapping(databases));

    return types.join('\n\n');
  }

  private generateBaseTypes(): string {
    return `// Auto-generated types for Notion databases
// Do not edit this file directly

export type NotionUser = {
  id: string;
  object?: 'user';
  name?: string;
  avatar_url?: string | null;
};

export type NotionFile = {
  name: string;
  url: string;
  type?: 'external' | 'file';
};

export type NotionDate = {
  start: string;
  end?: string | null;
  time_zone?: string | null;
};

export type NotionSelectOption = {
  id?: string;
  name: string;
  color?: string;
};`;
  }

  private async generateDatabaseTypes(database: ResolvedDatabaseConfig): Promise<string> {
    const types: string[] = [];

    // メインのデータベース型
    const schema = this.schemaGenerator.generateJSONSchema(database);
    const mainType = await compile(schema, database.name, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(mainType);

    // Create型
    const createSchema = this.schemaGenerator.generateCreateSchema(database);
    const createType = await compile(createSchema, `Create${database.name}`, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(createType);

    // Update型
    const updateSchema = this.schemaGenerator.generateUpdateSchema(database);
    const updateType = await compile(updateSchema, `Update${database.name}`, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(updateType);

    // Enum型を生成（select/multi_select/status用）
    const enumTypes = this.generateEnumTypes(database);
    if (enumTypes) {
      types.push(enumTypes);
    }

    return types.join('\n\n');
  }

  private generateEnumTypes(database: ResolvedDatabaseConfig): string | null {
    const enums: string[] = [];

    for (const prop of database.properties) {
      if (
        (prop.type === 'select' || prop.type === 'multi_select' || prop.type === 'status') &&
        prop.options &&
        prop.options.length > 0
      ) {
        const enumName = `${database.name}${this.capitalize(prop.name)}Options`;
        const enumValues = prop.options
          .map((opt: any) => `  | '${opt.name.replace(/'/g, "\\'")}'`)
          .join('\n');

        enums.push(`export type ${enumName} =\n${enumValues};`);
      }
    }

    return enums.length > 0 ? enums.join('\n\n') : null;
  }

  private generateDatabaseMapping(databases: ResolvedDatabaseConfig[]): string {
    const mappings = databases.map((db) => `  '${db.id}': ${db.name};`).join('\n');
    const names = databases.map((db) => `  | '${db.name}'`).join('\n');

    // 条件型の生成を修正
    const createConditions = databases
      .map((db) => `T extends '${db.name}' ? Create${db.name} :`)
      .join('\n  ');
    const createType = `export type GetCreateType<T extends DatabaseNames> = ${createConditions}\n  never;`;

    const updateConditions = databases
      .map((db) => `T extends '${db.name}' ? Update${db.name} :`)
      .join('\n  ');
    const updateType = `export type GetUpdateType<T extends DatabaseNames> = ${updateConditions}\n  never;`;

    const nameToTypeMapping = databases.map((db) => `  '${db.name}': ${db.name};`).join('\n');

    return `export type DatabaseIdMapping = {
${mappings}
};

export type DatabaseNameMapping = {
${nameToTypeMapping}
};

export type DatabaseNames =
${names};

export type GetDatabaseType<T extends keyof DatabaseIdMapping> = DatabaseIdMapping[T];
export type GetDatabaseTypeByName<T extends DatabaseNames> = DatabaseNameMapping[T];
${createType}
${updateType}`;
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
