import { compile } from 'json-schema-to-typescript';
import type { ResolvedDatabaseConfig } from '../types';
import { SchemaGenerator } from './SchemaGenerator';

export class TypeGenerator {
  private schemaGenerator: SchemaGenerator;

  constructor() {
    this.schemaGenerator = new SchemaGenerator();
  }

  async generateTypes(databases: ResolvedDatabaseConfig[]): Promise<string> {
    const types: string[] = [];

    // 基本的な型定義を追加
    types.push(this.generateBaseTypes());

    // 基本フィルター型を一度だけ追加
    types.push(this.generateBasicFilterTypes());

    // 各データベースの型を生成
    for (const database of databases) {
      const dbTypes = await this.generateDatabaseTypes(database);
      types.push(dbTypes);
    }

    // データベースマッピング型を生成
    types.push(this.generateDatabaseMapping(databases));

    return types.join('\n\n');
  }

  private generateBaseTypes(): string {
    return `// Auto-generated types for Notion databases
// Do not edit this file directly

export type NotionUser = {
  id: string;
  object?: 'user';
  name?: string;
  avatar_url?: string | null;
};

export type NotionFile = {
  name: string;
  url: string;
  type?: 'external' | 'file';
};

export type NotionDate = {
  start: string;
  end?: string | null;
  time_zone?: string | null;
};

export type NotionSelectOption = {
  id?: string;
  name: string;
  color?: string;
};

export type NotionStatusGroup = {
  id: string;
  name: string;
  color: string;
  option_ids: string[];
};`;
  }

  private async generateDatabaseTypes(database: ResolvedDatabaseConfig): Promise<string> {
    const types: string[] = [];

    // メインのデータベース型
    const schema = this.schemaGenerator.generateJSONSchema(database);
    const mainType = await compile(schema, database.name, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(mainType);

    // Create型
    const createSchema = this.schemaGenerator.generateCreateSchema(database);
    const createType = await compile(createSchema, `Create${database.name}`, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(createType);

    // Update型
    const updateSchema = this.schemaGenerator.generateUpdateSchema(database);
    const updateType = await compile(updateSchema, `Update${database.name}`, {
      bannerComment: '',
      declareExternallyReferenced: false,
      enableConstEnums: false,
      format: false,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: false,
      unknownAny: false,
      unreachableDefinitions: false,
    });
    types.push(updateType);

    // Enum型を生成（select/multi_select/status用）
    const enumTypes = this.generateEnumTypes(database);
    if (enumTypes) {
      types.push(enumTypes);
    }

    // Status group型を生成
    const groupTypes = this.generateStatusGroupTypes(database);
    if (groupTypes) {
      types.push(groupTypes);
    }

    // Filter型を生成
    const filterTypes = this.generateFilterTypes(database);
    if (filterTypes) {
      types.push(filterTypes);
    }

    return types.join('\n\n');
  }

  private generateEnumTypes(database: ResolvedDatabaseConfig): string | null {
    const enums: string[] = [];

    for (const prop of database.properties) {
      if (
        (prop.type === 'select' || prop.type === 'multi_select' || prop.type === 'status') &&
        prop.options &&
        prop.options.length > 0
      ) {
        const enumName = `${database.name}${this.capitalize(prop.name)}Options`;
        const enumValues = prop.options
          .map((opt: any) => `  | '${opt.name.replace(/'/g, "\\'")}'`)
          .join('\n');

        enums.push(`export type ${enumName} =\n${enumValues};`);
      }
    }

    return enums.length > 0 ? enums.join('\n\n') : null;
  }

  private generateStatusGroupTypes(database: ResolvedDatabaseConfig): string | null {
    const groupTypes: string[] = [];

    for (const prop of database.properties) {
      if (prop.type === 'status' && prop.groups && prop.groups.length > 0) {
        // Generate group enum type
        const groupEnumName = `${database.name}${this.capitalize(prop.name)}Groups`;
        const groupValues = prop.groups
          .map((group: any) => `  | '${group.name.replace(/'/g, "\\'")}'`)
          .join('\n');

        groupTypes.push(`export type ${groupEnumName} =\n${groupValues};`);

        // Generate group-to-options mapping type
        const mappingTypeName = `${database.name}${this.capitalize(prop.name)}GroupMapping`;
        const mappingEntries = prop.groups
          .map((group: any) => {
            const optionNames = group.option_ids
              .map((optionId: string) => {
                const option = prop.options?.find((opt: any) => opt.id === optionId);
                return option ? `'${option.name.replace(/'/g, "\\'")}'` : null;
              })
              .filter(Boolean)
              .join(' | ');

            return `  '${group.name.replace(/'/g, "\\'")}': ${optionNames || 'never'};`;
          })
          .join('\n');

        groupTypes.push(`export type ${mappingTypeName} = {\n${mappingEntries}\n};`);

        // Generate option-to-group mapping type (reverse mapping)
        const reverseTypeName = `${database.name}${this.capitalize(prop.name)}OptionToGroupMapping`;
        const reverseEntries =
          prop.options
            ?.map((option: any) => {
              const group = prop.groups?.find((g: any) => g.option_ids.includes(option.id));
              return group
                ? `  '${option.name.replace(/'/g, "\\'")}': '${group.name.replace(/'/g, "\\'")}'`
                : null;
            })
            .filter(Boolean)
            .join(';\n') || '';

        if (reverseEntries) {
          groupTypes.push(`export type ${reverseTypeName} = {\n${reverseEntries};\n};`);
        }

        // Generate strict name-group combination type (NEW!)
        const strictCombinationTypeName = `${database.name}${this.capitalize(prop.name)}NameGroupPair`;
        const strictCombinations =
          prop.options
            ?.map((option: any) => {
              const group = prop.groups?.find((g: any) => g.option_ids.includes(option.id));
              return group
                ? `  | { name: '${option.name.replace(/'/g, "\\'")}'; group: '${group.name.replace(/'/g, "\\'")}'; color?: string; [k: string]: any }`
                : null;
            })
            .filter(Boolean)
            .join('\n') || '';

        if (strictCombinations) {
          groupTypes.push(`export type ${strictCombinationTypeName} =\n${strictCombinations};`);
        }
      }
    }

    return groupTypes.length > 0 ? groupTypes.join('\n\n') : null;
  }

  private generateFilterTypes(database: ResolvedDatabaseConfig): string | null {
    const filterTypes: string[] = [];

    // Property-specific filter types
    const propertyFilterTypes = this.generatePropertyFilterTypes(database);
    if (propertyFilterTypes) {
      filterTypes.push(propertyFilterTypes);
    }

    // Main database filter type
    const mainFilterType = this.generateDatabaseFilterType(database);
    filterTypes.push(mainFilterType);

    return filterTypes.join('\n\n');
  }

  private generateBasicFilterTypes(): string {
    return `// Basic filter condition types - mutually exclusive conditions
export type TextFilter = 
  | { equals: string }
  | { does_not_equal: string }
  | { contains: string }
  | { does_not_contain: string }
  | { starts_with: string }
  | { ends_with: string }
  | { is_empty: true }
  | { is_not_empty: true };

export type NumberFilter = 
  | { equals: number }
  | { does_not_equal: number }
  | { greater_than: number }
  | { less_than: number }
  | { greater_than_or_equal_to: number }
  | { less_than_or_equal_to: number }
  | { is_empty: true }
  | { is_not_empty: true };

export type CheckboxFilter = 
  | { equals: boolean }
  | { does_not_equal: boolean };

export type DateFilter = 
  | { equals: string }
  | { before: string }
  | { after: string }
  | { on_or_before: string }
  | { on_or_after: string }
  | { past_week: Record<string, never> }
  | { past_month: Record<string, never> }
  | { past_year: Record<string, never> }
  | { next_week: Record<string, never> }
  | { next_month: Record<string, never> }
  | { next_year: Record<string, never> }
  | { is_empty: true }
  | { is_not_empty: true };

export type SelectFilter<T extends string> = 
  | { equals: T }
  | { does_not_equal: T }
  | { is_empty: true }
  | { is_not_empty: true };

export type MultiSelectFilter<T extends string> = 
  | { contains: T }
  | { does_not_contain: T }
  | { is_empty: true }
  | { is_not_empty: true };

// People and relation filters
export type PeopleFilter = 
  | { contains: string }
  | { does_not_contain: string }
  | { is_empty: true }
  | { is_not_empty: true };

export type RelationFilter = 
  | { contains: string }
  | { does_not_contain: string }
  | { is_empty: true }
  | { is_not_empty: true };

// Formula filters (depends on formula return type)
export type FormulaFilter = 
  | { string: TextFilter }
  | { checkbox: CheckboxFilter }
  | { number: NumberFilter }
  | { date: DateFilter };

// Rollup filters (depends on rollup property type)
export type RollupFilter = 
  | { any: TextFilter | NumberFilter | DateFilter | CheckboxFilter }
  | { every: TextFilter | NumberFilter | DateFilter | CheckboxFilter }
  | { none: TextFilter | NumberFilter | DateFilter | CheckboxFilter }
  | { string: TextFilter }
  | { number: NumberFilter }
  | { date: DateFilter }
  | { checkbox: CheckboxFilter };

// Timestamp filters (for created_time, last_edited_time)
export type TimestampFilter = 
  | { equals: string }
  | { before: string }
  | { after: string }
  | { on_or_before: string }
  | { on_or_after: string }
  | { past_week: Record<string, never> }
  | { past_month: Record<string, never> }
  | { past_year: Record<string, never> }
  | { next_week: Record<string, never> }
  | { next_month: Record<string, never> }
  | { next_year: Record<string, never> };

// Unique ID filters
export type UniqueIdFilter = 
  | { equals: number }
  | { does_not_equal: number }
  | { greater_than: number }
  | { less_than: number }
  | { greater_than_or_equal_to: number }
  | { less_than_or_equal_to: number };`;
  }

  private generatePropertyFilterTypes(database: ResolvedDatabaseConfig): string | null {
    const propertyFilters: string[] = [];

    for (const prop of database.properties) {
      const propertyName = this.capitalize(prop.name);
      let filterType: string;

      switch (prop.type) {
        case 'title':
        case 'rich_text':
        case 'url':
        case 'email':
        case 'phone_number':
          filterType = 'TextFilter';
          break;
        case 'number':
          filterType = 'NumberFilter';
          break;
        case 'checkbox':
          filterType = 'CheckboxFilter';
          break;
        case 'date':
          filterType = 'DateFilter';
          break;
        case 'created_time':
        case 'last_edited_time':
          filterType = 'TimestampFilter';
          break;
        case 'people':
        case 'created_by':
        case 'last_edited_by':
          filterType = 'PeopleFilter';
          break;
        case 'relation':
          filterType = 'RelationFilter';
          break;
        case 'formula':
          filterType = 'FormulaFilter';
          break;
        case 'rollup':
          filterType = 'RollupFilter';
          break;
        case 'select':
        case 'status':
          if (prop.options && prop.options.length > 0) {
            const optionsType = `${database.name}${propertyName}Options`;
            filterType = `SelectFilter<${optionsType}>`;
          } else {
            filterType = 'SelectFilter<string>';
          }
          break;
        case 'multi_select':
          if (prop.options && prop.options.length > 0) {
            const optionsType = `${database.name}${propertyName}Options`;
            filterType = `MultiSelectFilter<${optionsType}>`;
          } else {
            filterType = 'MultiSelectFilter<string>';
          }
          break;
        case 'unique_id':
          filterType = 'UniqueIdFilter';
          break;
        default:
          continue; // Skip unsupported property types
      }

      const propertyFilterName = `${database.name}${propertyName}PropertyFilter`;
      propertyFilters.push(`export type ${propertyFilterName} = {
  property: '${prop.name}';
  ${prop.type}: ${filterType};
};`);
    }

    return propertyFilters.length > 0 ? propertyFilters.join('\n\n') : null;
  }

  private generateDatabaseFilterType(database: ResolvedDatabaseConfig): string {
    const supportedPropertyTypes = [
      'title',
      'rich_text',
      'url',
      'email',
      'phone_number',
      'number',
      'checkbox',
      'date',
      'created_time',
      'last_edited_time',
      'people',
      'created_by',
      'last_edited_by',
      'relation',
      'formula',
      'rollup',
      'select',
      'status',
      'multi_select',
      'unique_id',
    ];

    const propertyFilterTypes: string[] = [];

    for (const prop of database.properties) {
      if (supportedPropertyTypes.includes(prop.type)) {
        const propertyName = this.capitalize(prop.name);
        propertyFilterTypes.push(`${database.name}${propertyName}PropertyFilter`);
      }
    }

    const filterTypeName = `${database.name}Filter`;

    if (propertyFilterTypes.length === 0) {
      return `export type ${filterTypeName} = Record<string, never>;`;
    }

    // Add special timestamp filters that don't require property field
    const specialFilters = ['TimestampCreatedTimeFilter', 'TimestampLastEditedTimeFilter'];

    // Create base filter type without compound filter to avoid circular reference
    const baseFilterTypeName = `${filterTypeName}Base`;

    return `// Special timestamp filters (no property field required)
export type TimestampCreatedTimeFilter = {
  timestamp: 'created_time';
  created_time: TimestampFilter;
};

export type TimestampLastEditedTimeFilter = {
  timestamp: 'last_edited_time';
  last_edited_time: TimestampFilter;
};

// Base filter type without compound filters
export type ${baseFilterTypeName} = 
  | ${propertyFilterTypes.join('\n  | ')}
  | ${specialFilters.join('\n  | ')};

// Compound filter type that can contain nested filters
export type CompoundFilter<T> = {
  and?: (T | CompoundFilter<T>)[];
} | {
  or?: (T | CompoundFilter<T>)[];
};

// Main filter type with compound filter support
export type ${filterTypeName} = 
  | ${baseFilterTypeName}
  | CompoundFilter<${baseFilterTypeName}>;`;
  }

  private generateDatabaseMapping(databases: ResolvedDatabaseConfig[]): string {
    const mappings = databases.map((db) => `  '${db.id}': ${db.name};`).join('\n');
    const names = databases.map((db) => `  | '${db.name}'`).join('\n');

    // 条件型の生成を修正
    const createConditions = databases
      .map((db) => `T extends '${db.name}' ? Create${db.name} :`)
      .join('\n  ');
    const createType = `export type GetCreateType<T extends DatabaseNames> = ${createConditions}\n  never;`;

    const updateConditions = databases
      .map((db) => `T extends '${db.name}' ? Update${db.name} :`)
      .join('\n  ');
    const updateType = `export type GetUpdateType<T extends DatabaseNames> = ${updateConditions}\n  never;`;

    const filterConditions = databases
      .map((db) => `T extends '${db.name}' ? ${db.name}Filter :`)
      .join('\n  ');
    const filterType = `export type GetFilterType<T extends DatabaseNames> = ${filterConditions}\n  never;`;

    const nameToTypeMapping = databases.map((db) => `  '${db.name}': ${db.name};`).join('\n');

    // Generate status property mapping for type safety
    const statusPropertyMappings: string[] = [];
    for (const db of databases) {
      const statusProps = db.properties.filter(
        (p) => p.type === 'status' && p.groups && p.groups.length > 0
      );
      if (statusProps.length > 0) {
        const propMappings = statusProps
          .map(
            (p) => `    '${p.name}': {
      groups: ${db.name}${this.capitalize(p.name)}Groups;
      options: ${db.name}${this.capitalize(p.name)}Options;
      groupMapping: ${db.name}${this.capitalize(p.name)}GroupMapping;
      optionToGroupMapping: ${db.name}${this.capitalize(p.name)}OptionToGroupMapping;
    }`
          )
          .join(';\n');

        statusPropertyMappings.push(`  '${db.name}': {
${propMappings};
  }`);
      }
    }

    const statusPropertyMapping =
      statusPropertyMappings.length > 0
        ? `\nexport type StatusPropertyMapping = {\n${statusPropertyMappings.join(';\n')};\n};`
        : '';

    // Generate helper types for type-safe property access
    const propertyHelpers =
      statusPropertyMappings.length > 0
        ? `\n// Helper types for type-safe status property access
export type GetStatusProperties<T extends DatabaseNames> = T extends keyof StatusPropertyMapping 
  ? keyof StatusPropertyMapping[T] 
  : never;

export type GetStatusGroups<T extends DatabaseNames, P extends GetStatusProperties<T>> = 
  T extends keyof StatusPropertyMapping 
    ? P extends keyof StatusPropertyMapping[T] 
      ? StatusPropertyMapping[T][P]['groups']
      : never
    : never;

export type GetStatusOptions<T extends DatabaseNames, P extends GetStatusProperties<T>> = 
  T extends keyof StatusPropertyMapping 
    ? P extends keyof StatusPropertyMapping[T] 
      ? StatusPropertyMapping[T][P]['options']
      : never
    : never;

export type GetStatusGroupMapping<T extends DatabaseNames, P extends GetStatusProperties<T>> = 
  T extends keyof StatusPropertyMapping 
    ? P extends keyof StatusPropertyMapping[T] 
      ? StatusPropertyMapping[T][P]['groupMapping']
      : never
    : never;

export type GetOptionToGroupMapping<T extends DatabaseNames, P extends GetStatusProperties<T>> = 
  T extends keyof StatusPropertyMapping 
    ? P extends keyof StatusPropertyMapping[T] 
      ? StatusPropertyMapping[T][P]['optionToGroupMapping']
      : never
    : never;`
        : '';

    return `export type DatabaseIdMapping = {
${mappings}
};

export type DatabaseNameMapping = {
${nameToTypeMapping}
};

export type DatabaseNames =
${names};

export type GetDatabaseType<T extends keyof DatabaseIdMapping> = DatabaseIdMapping[T];
export type GetDatabaseTypeByName<T extends DatabaseNames> = DatabaseNameMapping[T];
${createType}
${updateType}
${filterType}${statusPropertyMapping}${propertyHelpers}`;
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
